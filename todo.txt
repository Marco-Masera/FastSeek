

Generic indexer:

    <bin> index <filename> <--column N> <--separator string> <--hashmap-size size>
        --column REQUIRED  (shortcut: -cN, for example -c0 for first column)
            >Indexed from 0, tell that to the user
        --separator <default: \t>
        --hasmap_size <default: num lines of original file>  (shortcut: -h1000)
            >(Structure is kept in-memory)
            >If user knows number of lines, better to provide them by hand - will make process faster

    <bin> search <filename> <KEYWORDS>  <--column N> <--separator string>  --print-duplicates
        KEYWORDS: string or sequence of strings to search
        --column REQUIRED  (shortcut: -cN, for example -c0 for first column)
                >Indexed from 0, tell that to the user
        --separator <default: \t>
        --print-duplicates: this flag prints all lines with the keyword, if more than one exist

Index file structure:
>Indexes: fixed length (64 * hashmap size)
    -Implicit map: <hash value>(position) -> index in block or 0
>Blocks: variable length (byte indexed)
    -Each entry is 64 x 2:
        -First int: offset in original file of the entry 
        -Second int: next block (linked-list-like) or 0
    Ottimizzazione::
        -Direct: se non ci sono conflitti, indice direttamente in hashtable
            -Se conflitti, usa blocchi
        -Usa primo bit dei 64 per distinguere puntatore a file da puntatore a blocco!


    TODO:
    Nuovo flag - allow duplicates:
        -In caso duplicati, stampali tutti
        -Conviene di default attivare contiguous blocks
    Nuovo flag - compress hashmap
        -Flag compressed hashmap: deve prima caricarla interamente in memoria, ma index + piccolo 
        -Se false (default): 2 file, hashmap in chiaro, blocchi compressi 
    Nuovo flag - contiguous block 
        -Invece di blocchi come linked list, blocchi contigui.
        -Accesso + veloce, dimezzi spazio perché non serve puntatore a next 
        -Usa primo bit x distinguere se è il primo elemento di un blocco o una continuazione
        -Indexing è significativamente più lento.
    Quando lanci index:
        -Stampa opzioni e raccomandazioni (es using linked-list blocks, not good for datasets with many duplicates)
    Multithreading


Banchmarking:
    >50M records:
        TIME: (RELEASE mode (optimizations ON))
            -28 seconds
            -26 seconds - hashmap_size as num_lines
            -17 second  - hasmap_size as 2*num_lines
            -12 seconds in RELEASE mode + hashmap_size specified as 4*num_lines
                vs 16 seconds of zcat > ..
            -Search - instant
        SPACE:
            -216M index 
                vs 2.8G uncompressed original data

    ==> Conflicts: C 4.597.713 slC: 1.294.257

    ==> Larger hasmap => Fewer collisions => WAY FASTER!
        -Check how much faster
        -Maybe do 2x by default
        -Maybe try to optimize inner code to make conflicts less problematic